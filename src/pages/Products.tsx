import React, { useState, useMemo, useEffect } from 'react';
import { Link, useSearchParams, useNavigate } from 'react-router-dom';
import { useCart } from '@/contexts/CartContext';
import MainHeader from '@/components/layout/MainHeader';
import CategorySidebar from '@/components/layout/CategorySidebar';
import Footer from '@/components/layout/Footer';
import WhatsAppWidget from '@/components/WhatsAppWidget';
import BackToTop from '@/components/BackToTop';
import { useWooCommerceProducts } from '@/hooks/useWooCommerceProducts';
import { useWooCommerceCategories } from '@/hooks/useWooCommerceCategories';
import { PCComponent } from '@/data/pcComponents';
import { categorySlugMap } from '@/data/woocommerce-categories';
import { Button } from '@/components/ui/button';
import { ShoppingCart, Heart, Search, Filter, Grid, List } from 'lucide-react';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Input } from '@/components/ui/input';

const Products = () => {
  const navigate = useNavigate();
  const [searchParams, setSearchParams] = useSearchParams();
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [shouldSearchAllForBags, setShouldSearchAllForBags] = useState(false);
  const [bagsFallbackActive, setBagsFallbackActive] = useState(false); // Track if fallback is successfully active

  // Handle tab changes - navigate to home page with the selected tab
  const handleTabChange = (tab: string) => {
    // Navigate to home page with state to indicate which tab to activate
    navigate('/', { state: { activeTab: tab } });
  };

  // Get filters from URL params
  const page = parseInt(searchParams.get('page') || '1', 10);
  const search = searchParams.get('search') || '';
  const categoryParam = searchParams.get('category') || '';
  const sortBy = searchParams.get('sort') || 'date';
  const sortOrder = searchParams.get('order') || 'desc';
  const featured = searchParams.get('featured') === 'true';

  // Reset fallback flag when category changes (but only if it's not bags category)
  useEffect(() => {
    const isBags = categoryParam && (
      categoryParam.toLowerCase() === 'bags' || 
      categoryParam.toLowerCase() === 'bag' ||
      categoryParam.toLowerCase() === 'laptop-bags'
    );
    // Only reset if we're leaving the bags category
    if (!isBags) {
      setShouldSearchAllForBags(false);
      setBagsFallbackActive(false);
    }
  }, [categoryParam]);

  // Fetch WooCommerce categories to map slugs to IDs
  const { getCategoryIdBySlug, loading: loadingCategories, categories } = useWooCommerceCategories();

  // Check if search term matches a category - if so, treat it as category filter instead of text search
  const searchCategoryMatch = useMemo(() => {
    if (!search || loadingCategories || categories.length === 0) return null;
    
    const searchLower = search.toLowerCase().trim();
    const searchHyphenated = searchLower.replace(/\s+/g, '-');
    const searchSpaced = searchLower.replace(/-/g, ' ');
    
    // Check if search term matches any category name or slug
    for (const cat of categories) {
      const catNameLower = cat.name?.toLowerCase() || '';
      const catSlugLower = cat.slug?.toLowerCase() || '';
      
      if (catNameLower === searchLower || 
          catNameLower === searchHyphenated || 
          catNameLower === searchSpaced ||
          catSlugLower === searchLower ||
          catSlugLower === searchHyphenated ||
          catSlugLower === searchSpaced ||
          catNameLower.includes(searchLower) ||
          catSlugLower.includes(searchLower)) {
        return cat;
      }
    }
    
    // Also check categorySlugMap for variations
    const variations = [searchLower, searchHyphenated, searchSpaced];
    for (const variation of variations) {
      if (categorySlugMap[variation]) {
        // Find the category by slug
        const matchedCat = categories.find(c => 
          categorySlugMap[variation].some(slug => 
            c.slug?.toLowerCase() === slug.toLowerCase()
          )
        );
        if (matchedCat) return matchedCat;
      }
    }
    
    return null;
  }, [search, loadingCategories, categories]);

  // Use AUTO-GENERATED category mapping from WooCommerce API
  // This mapping includes ALL 147 WooCommerce categories with all variations
  // Generated by: node scripts/generate-category-mapping.js
  // To update categories, just run the script - no code changes needed!

  // Determine WooCommerce category IDs from URL parameter OR search term (if search matches a category)
  // Returns array because some categories map to multiple WooCommerce categories (e.g., RAM, Storage)
  const wooCommerceCategoryIds = useMemo(() => {
    // If search term matches a category, use that category instead of categoryParam
    const effectiveCategoryParam = searchCategoryMatch ? searchCategoryMatch.slug : categoryParam;
    
    if (!effectiveCategoryParam) return undefined;
    
    // If it's already a number, use it directly
    if (!isNaN(parseInt(categoryParam, 10))) {
      return [parseInt(categoryParam, 10)];
    }

    // If categories are still loading, wait for them
    // In production, categories might load slower, so we wait
    if (loadingCategories) {
      console.log(`‚è≥ Categories still loading, will retry lookup for: "${effectiveCategoryParam}"`);
      
      // FALLBACK: For known categories, use hardcoded IDs if categories are taking too long
      // This helps in production where API might be slower
      const knownCategoryIds: Record<string, number> = {
        'graphic-cards': 118,
        'graphic-card': 118,
        'gpu': 118,
        'gpus': 118,
        'graphics-card': 118,
        'graphics-cards': 118,
        'video-card': 118,
        'video-cards': 118,
        'cpu': 117,
        'processors': 117,
        'processor': 117,
        'motherboards': 116,
        'motherboard': 116,
        'ram': 110,
        'memory': 110,
        'storage-drives': 113,
        'storage': 113,
        'cases': 119,
        'case': 119,
        'coolers-fans': 114,
        'cooler': 114,
        'headsets': 121,
        'keyboards': 127,
        'mouse': 130,
      };
      
      const normalizedParam = effectiveCategoryParam.toLowerCase().trim();
      if (knownCategoryIds[normalizedParam]) {
        console.log(`‚ö†Ô∏è Using fallback category ID ${knownCategoryIds[normalizedParam]} for "${effectiveCategoryParam}" (categories still loading)`);
        return [knownCategoryIds[normalizedParam]];
      }
      
      return undefined; // Return undefined to trigger re-evaluation when categories load
    }
    
    // If categories array is empty but not loading, there might be an issue
    // Use fallback IDs for known categories
    if (categories.length === 0 && !loadingCategories) {
      console.warn(`‚ö†Ô∏è Categories array is empty but not loading. Using fallback IDs for: "${effectiveCategoryParam}"`);
      
      const knownCategoryIds: Record<string, number> = {
        'graphic-cards': 118,
        'graphic-card': 118,
        'gpu': 118,
        'gpus': 118,
        'graphics-card': 118,
        'graphics-cards': 118,
        'video-card': 118,
        'video-cards': 118,
        'cpu': 117,
        'processors': 117,
        'processor': 117,
        'motherboards': 116,
        'motherboard': 116,
        'ram': 110,
        'memory': 110,
        'storage-drives': 113,
        'storage': 113,
        'cases': 119,
        'case': 119,
        'coolers-fans': 114,
        'cooler': 114,
        'headsets': 121,
        'keyboards': 127,
        'mouse': 130,
      };
      
      const normalizedParam = effectiveCategoryParam.toLowerCase().trim();
      if (knownCategoryIds[normalizedParam]) {
        console.log(`‚úì Using fallback category ID ${knownCategoryIds[normalizedParam]} for "${effectiveCategoryParam}"`);
        return [knownCategoryIds[normalizedParam]];
      }
    }
    
    // If search matched a category directly, use its ID
    if (searchCategoryMatch && searchCategoryMatch.id) {
      return [searchCategoryMatch.id];
    }

    // FIRST: Try direct lookup from categories (for subcategories from backend)
    // This is faster and more reliable for categories that come from the backend
    const categoryIds: number[] = [];
    if (categories.length > 0) {
      const searchSlug = effectiveCategoryParam.toLowerCase().trim();
      
      // Try exact match first - if multiple matches, prioritize by context
      const exactMatches = categories.filter(cat => {
        const catSlug = cat.slug?.toLowerCase().trim() || '';
        return catSlug === searchSlug;
      });
      
      if (exactMatches.length > 0) {
        // If multiple matches (e.g., "cooler" appears in multiple categories)
        // Prioritize based on product count or specific category ID
        let selectedMatch = exactMatches[0];
        
        // For "cooler" category, ALWAYS prioritize the laptop accessories cooler (ID 11790) if it exists
        // This ensures we show laptop coolers, not PC component coolers
        if (searchSlug === 'cooler') {
          const laptopCooler = exactMatches.find(cat => cat.id === 11790);
          if (laptopCooler) {
            selectedMatch = laptopCooler;
            console.log(`  ‚úì Prioritized laptop accessories cooler (ID: 11790) over other cooler categories`);
          } else if (exactMatches.length > 1) {
            // If ID 11790 not found, prefer the one with fewer products (likely the specific subcategory)
            selectedMatch = exactMatches.reduce((prev, curr) => 
              (curr.count || 0) < (prev.count || 0) ? curr : prev
            );
          }
        }
        
        categoryIds.push(selectedMatch.id);
        console.log(`‚úì Found category by exact slug match: "${selectedMatch.name}" (ID: ${selectedMatch.id}, Slug: "${selectedMatch.slug}", Count: ${selectedMatch.count || 0})`);
        if (exactMatches.length > 1) {
          console.log(`  Note: Found ${exactMatches.length} categories with slug "${searchSlug}", selected: ${selectedMatch.name} (ID: ${selectedMatch.id})`);
        }
        return categoryIds;
      }
      
      // Try name match
      const nameMatch = categories.find(cat => {
        const catName = cat.name?.toLowerCase().trim() || '';
        const normalizedName = searchSlug.replace(/-/g, ' ').replace(/\s+/g, ' ').trim();
        return catName === normalizedName || catName === searchSlug;
      });
      
      if (nameMatch) {
        categoryIds.push(nameMatch.id);
        console.log(`‚úì Found category by name match: "${nameMatch.name}" (ID: ${nameMatch.id}, Slug: "${nameMatch.slug}")`);
        return categoryIds;
      }
    }

    // SECOND: Try categorySlugMap (for legacy/internal category mappings)
    const originalParam = effectiveCategoryParam.toLowerCase();
    const hyphenated = originalParam.replace(/\s+/g, '-');
    const spaced = originalParam.replace(/-/g, ' ');
    
    // Get all possible slugs from our mapping - try multiple variations
    const possibleSlugs: string[] = [];
    
    // Try all variations: original, hyphenated, spaced
    const variations = [originalParam, hyphenated, spaced].filter((v, i, arr) => arr.indexOf(v) === i);
    
    for (const variation of variations) {
      // Direct match in categorySlugMap
      if (categorySlugMap[variation]) {
        possibleSlugs.push(...categorySlugMap[variation]);
      }
    }
    
    // If still not found, try to find by checking all category mappings
    if (possibleSlugs.length === 0) {
      for (const variation of variations) {
        for (const [key, slugs] of Object.entries(categorySlugMap)) {
          if (variation === key || slugs.includes(variation)) {
            possibleSlugs.push(...slugs);
            break;
          }
        }
        if (possibleSlugs.length > 0) break;
      }
    }
    
    // Remove duplicates
    const uniqueSlugs = Array.from(new Set(possibleSlugs));
    
    // Convert slugs to category IDs (collect all, not just first)
    // IMPORTANT: Only do this if categories are loaded, otherwise getCategoryIdBySlug will return null
    if (!loadingCategories && categories.length > 0) {
      for (const slug of uniqueSlugs) {
        const categoryId = getCategoryIdBySlug(slug);
        if (categoryId && !categoryIds.includes(categoryId)) {
          categoryIds.push(categoryId);
        }
      }
    } else if (uniqueSlugs.length > 0) {
      // If categories are still loading, log that we're waiting
      console.log(`Categories still loading, will retry lookup for slugs: ${uniqueSlugs.join(', ')}`);
    }
    
    // THIRD: Fallback - try fuzzy match from categories if still no match
    if (categoryIds.length === 0 && categories.length > 0) {
      const searchSlug = effectiveCategoryParam.toLowerCase().trim();
      const fuzzyMatch = categories.find(cat => {
        const catSlug = cat.slug?.toLowerCase() || '';
        const catName = cat.name?.toLowerCase() || '';
        return catSlug.includes(searchSlug) || searchSlug.includes(catSlug) ||
               catName.includes(searchSlug) || searchSlug.includes(catName);
      });
      
      if (fuzzyMatch) {
        categoryIds.push(fuzzyMatch.id);
        console.log(`‚úì Found category by fuzzy match: "${fuzzyMatch.name}" (ID: ${fuzzyMatch.id}, Slug: "${fuzzyMatch.slug}")`);
      }
    }
    
    // Debug logging
    if (effectiveCategoryParam && categoryIds.length === 0) {
      console.error(`‚ùå Could not find WooCommerce category IDs for: "${effectiveCategoryParam}"`);
      console.error(`   Tried variations: ${variations.join(', ')}`);
      console.error(`   Mapped to slugs: ${uniqueSlugs.join(', ')}`);
      console.error(`   Categories loaded: ${!loadingCategories}, Count: ${categories.length}`);
      if (categories.length > 0) {
        // Show all available category slugs for debugging
        const allSlugs = categories.map(c => c.slug).filter(Boolean).slice(0, 20);
        console.error(`   Available category slugs (first 20): ${allSlugs.join(', ')}`);
        
        const matchingCats = categories.filter(c => {
          const catSlug = c.slug?.toLowerCase() || '';
          const catName = c.name?.toLowerCase() || '';
          const searchSlug = effectiveCategoryParam.toLowerCase();
          return catSlug.includes(searchSlug) || searchSlug.includes(catSlug) ||
                 catName.includes(searchSlug) || searchSlug.includes(catName);
        });
        if (matchingCats.length > 0) {
          console.error(`   Found similar categories: ${matchingCats.map(c => `${c.name} (ID: ${c.id}, Slug: ${c.slug})`).join(', ')}`);
        }
      }
    } else if (effectiveCategoryParam && categoryIds.length > 0) {
      console.log(`‚úì Found WooCommerce category IDs [${categoryIds.join(', ')}] for: "${effectiveCategoryParam}" (mapped to: ${uniqueSlugs.join(', ') || 'direct lookup'})`);
    }

    // FALLBACK: If no category IDs found but we have a known category, use hardcoded ID
    // This ensures graphic-cards always works even if category lookup fails
    if (categoryIds.length === 0 && effectiveCategoryParam) {
      const knownCategoryIds: Record<string, number> = {
        'graphic-cards': 118,
        'graphic-card': 118,
        'gpu': 118,
        'gpus': 118,
        'graphics-card': 118,
        'graphics-cards': 118,
        'video-card': 118,
        'video-cards': 118,
        'cpu': 117,
        'processors': 117,
        'processor': 117,
        'motherboards': 116,
        'motherboard': 116,
        'ram': 110,
        'memory': 110,
        'storage-drives': 113,
        'storage': 113,
        'cases': 119,
        'case': 119,
        'coolers-fans': 114,
        'cooler': 114,
        'headsets': 121,
        'keyboards': 127,
        'mouse': 130,
      };
      
      const normalizedParam = effectiveCategoryParam.toLowerCase().trim();
      if (knownCategoryIds[normalizedParam]) {
        console.log(`‚ö†Ô∏è Using fallback category ID ${knownCategoryIds[normalizedParam]} for "${effectiveCategoryParam}" (category lookup returned no IDs)`);
        return [knownCategoryIds[normalizedParam]];
      }
    }

    return categoryIds.length > 0 ? categoryIds : undefined;
  }, [categoryParam, searchCategoryMatch, getCategoryIdBySlug, loadingCategories, categories, categorySlugMap]);

  // Map our internal category name to ComponentCategory for filtering
  // NOTE: Laptops are NOT PC components, so we don't filter by internal category for them
  // Also consider searchCategoryMatch if search term matches a category
  const internalCategoryFilter = useMemo(() => {
    // Use searchCategoryMatch slug if available, otherwise use categoryParam
    const effectiveCategory = searchCategoryMatch?.slug || categoryParam;
    if (!effectiveCategory) return undefined;
    
    const normalized = effectiveCategory.toLowerCase();
    
    // Check if it's a laptop category, gaming furniture, TV categories, bags, or other non-PC component categories - these should NOT be filtered by PC component categories
    const nonPCComponentCategories = ['gaming-laptops', 'gaming-laptop', 'gaming laptops', 'business-laptops', 'business laptops', 'laptops', 'laptop', 'desktops', 'desktop', 'imac-mac-mini-studio', 'imac', 'mac-mini', 'gaming-chairs-desks', 'gaming-chairs', 'gaming-desks', 'gaming chairs', 'gaming desks', 'tv-accessories', 'tv accessories', 'tv-bracket', 'tv brackets', 'smart-home', 'smart home', 'external-memory', 'external memory', 'usb-drive', 'usb drive', 'usb drives', 'usb-drives', 'bags', 'bag', 'backpacks', 'backpack'];
    if (nonPCComponentCategories.includes(normalized)) {
      return undefined; // Don't filter these by PC component category
    }
    
    // Map to our internal category types (PC components only)
    const internalMap: Record<string, string> = {
      'cpu': 'cpu',
      'cpus': 'cpu',
      'gpu': 'gpu',
      'graphic-cards': 'gpu',
      'graphics-card': 'gpu',
      'motherboard': 'motherboard',
      'motherboards': 'motherboard',
      'motherboard mainboard': 'motherboard', // Handle "motherboard mainboard" search
      'mainboard': 'motherboard',
      'ram': 'ram',
      'rams': 'ram',
      'ram memory ddr': 'ram', // Handle "ram memory ddr" search
      'memory': 'ram',
      'ddr': 'ram',
      'desktop-ram': 'ram',
      'notebook-ram': 'ram',
      'storage': 'storage',
      'storage-drives': 'storage', // Main storage category
      'storage-drive': 'storage',
      'internal-storage': 'storage',
      'external-storage': 'storage',
      'psu': 'psu',
      'power-supplies': 'psu',
      'power-supply': 'psu',
      'case': 'case',
      'cases': 'case',
      'cooler': 'cooler',
      'coolers-fans': 'cooler',
      'monitor': 'monitor',
      'monitors': 'monitor',
      'mouse': 'mouse',
      'mouses': 'mouse',
      'keyboard': 'keyboard',
      'keyboards': 'keyboard',
      'headset': 'headset',
      'headsets': 'headset',
    };

    return internalMap[normalized] || undefined;
  }, [categoryParam, searchCategoryMatch]);

  // Fetch products using WooCommerce category ID
  // Only use search fallback if category is NOT in our mapping (unknown categories)
  // For mapped categories, we should find the ID - if not, don't use search fallback to avoid wrong results
  const normalizedCategoryParam = categoryParam ? categoryParam.toLowerCase().replace(/\s+/g, '-') : '';
  // Check if category is in our mapping - if it is, NEVER use search fallback
  const categoryParamLower = categoryParam ? categoryParam.toLowerCase() : '';
  const isMappedCategory = categoryParam && (
    categorySlugMap[normalizedCategoryParam] !== undefined || 
    categorySlugMap[categoryParamLower] !== undefined ||
    Object.keys(categorySlugMap).some(key => {
      const normalizedKey = key.toLowerCase();
      return normalizedCategoryParam === normalizedKey || 
             categoryParamLower === normalizedKey ||
             normalizedCategoryParam.includes(normalizedKey) || 
             normalizedKey.includes(normalizedCategoryParam);
    })
  );
  
  // NEVER use search fallback for mapped categories - if category ID not found, show empty rather than wrong products
  // Only use search fallback for completely unknown categories that aren't in our mapping
  // IMPORTANT: If search term matches a category, don't use text search - use category filtering instead
  const shouldUseSearchFallback = !search && // Only use fallback if there's no user search
                                   !isMappedCategory && 
                                   (!wooCommerceCategoryIds || wooCommerceCategoryIds.length === 0) && 
                                   categoryParam && 
                                   !loadingCategories && 
                                   categories.length > 0;
  
  // Priority: 
  // 1) If search matches a category, use category filtering (no text search)
  // 2) If search doesn't match category, use text search
  // 3) Category search fallback (only if no user search and category ID not found)
  // 4) Bags fallback search (if bagsFallbackActive is true)
  const searchTerm = searchCategoryMatch 
    ? undefined // Don't use text search if search matches a category - use category filtering instead
    : (search || (shouldUseSearchFallback 
        ? categoryParam.replace(/-/g, ' ') // Use category name as search term if ID not found AND not a mapped category AND no user search
        : undefined));
  
  // Debug logging (can be removed in production)
  // if (categoryParam || search) {
  //   console.log(`Category filter: "${categoryParam || 'none'}" ‚Üí IDs: ${wooCommerceCategoryIds ? wooCommerceCategoryIds.join(', ') : 'NOT FOUND'}, Is Mapped: ${isMappedCategory}, Search: "${search || 'none'}", Search term: "${searchTerm || 'none'}"`);
  //   if (categoryParam && isMappedCategory && (!wooCommerceCategoryIds || wooCommerceCategoryIds.length === 0)) {
  //     console.error(`ERROR: Category "${categoryParam}" is in mapping but category ID not found! This will show empty results.`);
  //   }
  // }

  // Check if this is a bags category that might need fallback search
  const isBagsCategory = categoryParam && (
    categoryParam.toLowerCase() === 'bags' || 
    categoryParam.toLowerCase() === 'bag' ||
    categoryParam.toLowerCase() === 'laptop-bags'
  );

  // When searching, we need to fetch ALL matching products from WooCommerce
  // then apply client-side AND filtering and pagination
  // WooCommerce search does OR logic, so we fetch all matches and filter client-side
  // For bags fallback, use a search term to find bag products instead of fetching all products
  const isSearching = searchTerm && !searchCategoryMatch;
  const isBagsFallback = (shouldSearchAllForBags || bagsFallbackActive) && isBagsCategory;

  // For categories that map to multiple WooCommerce categories (e.g., RAM, Storage),
  // we need to fetch from all of them and combine. For now, use the first category ID.
  // TODO: Implement parallel fetching from multiple categories
  // IMPORTANT: Don't filter by category when user is searching - search across all products
  // For bags category, if we need to search all products, don't filter by category
  const primaryCategoryId = (searchTerm && !searchCategoryMatch) 
    ? undefined // Don't filter by category when searching
    : (isBagsFallback)
    ? undefined // Don't filter by category when using bags fallback search
    : (wooCommerceCategoryIds && wooCommerceCategoryIds.length > 0 ? wooCommerceCategoryIds[0] : undefined);
  // For bags fallback, search for bag-related keywords to limit results
  const bagsSearchTerm = isBagsFallback ? 'bag backpack laptop case' : undefined;
  // For laptop accessories cooler (ID 11790), fetch all products so we can filter client-side
  const isLaptopAccessoriesCooler = wooCommerceCategoryIds && wooCommerceCategoryIds.includes(11790);
  const shouldFetchAll = isSearching || isLaptopAccessoriesCooler; // Fetch all when searching or viewing laptop accessories cooler
  
  // Debug logging for category filtering
  useEffect(() => {
    if (categoryParam === 'graphic-cards' || categoryParam === 'gpu') {
      console.log('üîç Graphics Cards Debug:', {
        categoryParam,
        wooCommerceCategoryIds,
        primaryCategoryId,
        internalCategoryFilter,
        isBagsFallback,
        searchTerm,
        loadingCategories,
        categoriesCount: categories.length
      });
    }
  }, [categoryParam, wooCommerceCategoryIds, primaryCategoryId, internalCategoryFilter, isBagsFallback, searchTerm, loadingCategories, categories.length]);

  const { products: allProducts, loading, error, totalProducts } = useWooCommerceProducts({
    per_page: (isSearching || isBagsFallback || isLaptopAccessoriesCooler) ? 100 : 24, // Fetch in batches of 100 when searching, bags fallback, or laptop accessories cooler
    page: (isSearching || isBagsFallback || isLaptopAccessoriesCooler) ? 1 : page, // Always start at page 1 when searching, bags fallback, or laptop accessories cooler
    fetchAll: shouldFetchAll, // Fetch ALL pages when searching or viewing laptop accessories cooler
    search: bagsSearchTerm || searchTerm, // Use bags search term for fallback, otherwise use regular search
    category: isBagsFallback ? undefined : primaryCategoryId, // Don't filter by category when doing bags fallback
    pc_component_category: isBagsFallback ? undefined : internalCategoryFilter, // Don't filter by pc_component_category when doing bags fallback
    orderby: sortBy as 'date' | 'price' | 'popularity' | 'rating' | 'title',
    order: sortOrder as 'asc' | 'desc',
    featured: featured || undefined,
  });

  // Handle bags fallback state updates based on filtered results
  // This runs after filtering to update state without causing infinite loops
  useEffect(() => {
    const isBags = categoryParam && (
      categoryParam.toLowerCase() === 'bags' || 
      categoryParam.toLowerCase() === 'bag' ||
      categoryParam.toLowerCase() === 'laptop-bags'
    );
    if (!isBags || internalCategoryFilter || loading) return;
    
    // Check if we need to trigger fallback - only if we have products but they're all non-bag
    const hasProducts = allProducts.length > 0;
    const needsFallback = hasProducts && !shouldSearchAllForBags && !bagsFallbackActive;
    
    if (needsFallback) {
      // Check if all products are non-bag products
      const categoryKeywords = ['bag', 'backpack', 'case', 'luggage', 'carry', 'travel', 'laptop bag', 'notebook bag', 'briefcase', 'messenger', 'tote', 'duffel', 'sleeve', 'pouch'];
      const hasBagProducts = allProducts.some(product => {
        const nameLower = product.name.toLowerCase();
        const descLower = (product.description || '').toLowerCase();
        const brandLower = (product.brand || '').toLowerCase();
        const searchText = `${nameLower} ${descLower} ${brandLower}`;
        return categoryKeywords.some(keyword => searchText.includes(keyword));
      });
      
      if (!hasBagProducts) {
        console.log('üîß Triggering bags fallback search...');
        setShouldSearchAllForBags(true);
      }
    } else if (shouldSearchAllForBags && hasProducts) {
      // If we're in fallback mode and have products, check if we found bags
      const categoryKeywords = ['bag', 'backpack', 'case', 'luggage', 'carry', 'travel', 'laptop bag', 'notebook bag', 'briefcase', 'messenger', 'tote', 'duffel', 'sleeve', 'pouch'];
      const hasBagProducts = allProducts.some(product => {
        const nameLower = product.name.toLowerCase();
        const descLower = (product.description || '').toLowerCase();
        const brandLower = (product.brand || '').toLowerCase();
        const searchText = `${nameLower} ${descLower} ${brandLower}`;
        return categoryKeywords.some(keyword => searchText.includes(keyword));
      });
      
      if (hasBagProducts) {
        setBagsFallbackActive(true);
      } else if (!loading) {
        // No bags found even with fallback, reset
        setShouldSearchAllForBags(false);
        setBagsFallbackActive(false);
      }
    }
  }, [allProducts, categoryParam, internalCategoryFilter, loading, shouldSearchAllForBags, bagsFallbackActive]);

  // Filter products by our internal category mapping to ensure accuracy
  // NOTE: For laptops, we don't filter by internal category since they're not PC components
  // Also rank search results by relevance
  const allFilteredProducts = useMemo(() => {
    // If loading and we have category/search, don't show old products
    if (loading && (categoryParam || search) && allProducts.length === 0) {
      return [];
    }
    
    let filtered = allProducts;
    
    // For laptop accessories cooler category (ID 11790), filter to show ONLY laptop coolers
    // Products might be in multiple categories, so we need to filter client-side
    const isLaptopAccessoriesCooler = wooCommerceCategoryIds && wooCommerceCategoryIds.includes(11790);
    
    if (isLaptopAccessoriesCooler) {
      const beforeCount = filtered.length;
      filtered = filtered.filter(product => {
        const nameLower = product.name.toLowerCase();
        const descLower = (product.description || '').toLowerCase();
        const brandLower = (product.brand || '').toLowerCase();
        const searchText = `${nameLower} ${descLower} ${brandLower}`;
        
        // Include laptop coolers - must have "laptop" or "notebook" AND "cooler" or "cooling"
        const isLaptopCooler = 
          searchText.includes('laptop cooler') ||
          searchText.includes('laptop cooling') ||
          searchText.includes('notebook cooler') ||
          searchText.includes('notebook cooling') ||
          searchText.includes('cooling pad') ||
          (searchText.includes('laptop') && (searchText.includes('cooler') || searchText.includes('cooling'))) ||
          (searchText.includes('notebook') && (searchText.includes('cooler') || searchText.includes('cooling')));
        
        // Exclude PC component coolers (AIO, CPU coolers, liquid coolers, etc.)
        const isPCCooler = 
          searchText.includes('cpu cooler') ||
          searchText.includes('cpu cooling') ||
          searchText.includes('aio') ||
          searchText.includes('liquid cooler') ||
          searchText.includes('air cooler') ||
          searchText.includes('tower cooler') ||
          searchText.includes('radiator') ||
          searchText.includes('water cooler') ||
          /(lga|am\d+|socket)/i.test(searchText); // CPU socket compatibility
        
        // Show only if it's a laptop cooler AND not a PC cooler
        return isLaptopCooler && !isPCCooler;
      });
      console.log(`üîß Laptop Cooler filter: ${beforeCount} ‚Üí ${filtered.length} products (showing only laptop coolers)`);
    }
    
    // For non-PC component categories (like bags, laptops, etc.), filter out products that don't match the category name
    // This helps when WooCommerce has products in the wrong category
    
    if (isBagsCategory && !internalCategoryFilter && (filtered.length > 0 || shouldSearchAllForBags || bagsFallbackActive)) {
      const beforeCount = filtered.length;
      const categoryKeywords = ['bag', 'backpack', 'case', 'luggage', 'carry', 'travel', 'laptop bag', 'notebook bag', 'briefcase', 'messenger', 'tote', 'duffel', 'sleeve', 'pouch'];
      
      // First, identify products that are clearly NOT bags
      const nonBagProducts = filtered.filter(product => {
        const nameLower = product.name.toLowerCase();
        const descLower = (product.description || '').toLowerCase();
        const brandLower = (product.brand || '').toLowerCase();
        const searchText = `${nameLower} ${descLower} ${brandLower}`;
        
        // Exclude obvious non-bag products (audio, adapters, cables, etc.)
        return searchText.includes('audio') ||
          searchText.includes('adapter') ||
          searchText.includes('cable') ||
          searchText.includes('headphone') ||
          searchText.includes('speaker') ||
          searchText.includes('microphone') ||
          searchText.includes('3.5mm') ||
          searchText.includes('dual socket') ||
          searchText.includes('extension cable') ||
          searchText.includes('hama 122') ||
          searchText.includes('tws') ||
          searchText.includes('earbud');
      });
      
      // Find products that ARE bags
      const bagProducts = filtered.filter(product => {
        const nameLower = product.name.toLowerCase();
        const descLower = (product.description || '').toLowerCase();
        const brandLower = (product.brand || '').toLowerCase();
        const searchText = `${nameLower} ${descLower} ${brandLower}`;
        
        // Product should contain at least one keyword related to bags
        return categoryKeywords.some(keyword => searchText.includes(keyword));
      });
      
      // If we found bag products, use only those
      // Otherwise, if all products are non-bag products, filter them out
      // But if some products are ambiguous, keep them
      if (bagProducts.length > 0) {
        filtered = bagProducts;
        console.log(`üîß Bags filter: ${beforeCount} ‚Üí ${filtered.length} products (found ${bagProducts.length} bag products)`);
        // Don't update state here - will be handled in useEffect
      } else if (nonBagProducts.length === filtered.length && filtered.length > 0) {
        // All products are clearly non-bag products
        // If we haven't tried searching all products yet, trigger fallback search
        if (!shouldSearchAllForBags && !loading) {
          console.log(`üîß Bags filter: ${beforeCount} ‚Üí 0 products (all products were non-bag products). Will trigger fallback search...`);
          // Don't update state here - will be handled in useEffect
          filtered = []; // Clear results temporarily while we fetch
        } else if (shouldSearchAllForBags && loading) {
          // We're already fetching fallback results, keep empty for now
          filtered = [];
        } else {
          // We already tried searching all products, filter them all out
          filtered = [];
          console.log(`üîß Bags filter: ${beforeCount} ‚Üí 0 products (all products were non-bag products, fallback search also found no bags)`);
        }
      } else {
        // Some products are ambiguous - keep products that aren't clearly non-bag
        filtered = filtered.filter(product => !nonBagProducts.includes(product));
        console.log(`üîß Bags filter: ${beforeCount} ‚Üí ${filtered.length} products (removed ${nonBagProducts.length} non-bag products, kept ${filtered.length} ambiguous products)`);
        // Don't update state here - will be handled in useEffect
      }
    } else if (isBagsCategory && !internalCategoryFilter && (shouldSearchAllForBags || bagsFallbackActive) && filtered.length > 0) {
      // We're in fallback mode - search all products for bag keywords
      const beforeCount = filtered.length;
      const categoryKeywords = ['bag', 'backpack', 'case', 'luggage', 'carry', 'travel', 'laptop bag', 'notebook bag', 'briefcase', 'messenger', 'tote', 'duffel', 'sleeve', 'pouch'];
      
      // Find products that ARE bags
      const bagProducts = filtered.filter(product => {
        const nameLower = product.name.toLowerCase();
        const descLower = (product.description || '').toLowerCase();
        const brandLower = (product.brand || '').toLowerCase();
        const searchText = `${nameLower} ${descLower} ${brandLower}`;
        
        // Product should contain at least one keyword related to bags
        return categoryKeywords.some(keyword => searchText.includes(keyword));
      });
      
      // Filter out obvious non-bag products
      const nonBagProducts = filtered.filter(product => {
        const nameLower = product.name.toLowerCase();
        const descLower = (product.description || '').toLowerCase();
        const brandLower = (product.brand || '').toLowerCase();
        const searchText = `${nameLower} ${descLower} ${brandLower}`;
        
        return searchText.includes('audio') ||
          searchText.includes('adapter') ||
          searchText.includes('cable') ||
          searchText.includes('headphone') ||
          searchText.includes('speaker') ||
          searchText.includes('microphone') ||
          searchText.includes('3.5mm') ||
          searchText.includes('dual socket') ||
          searchText.includes('extension cable') ||
          searchText.includes('hama 122') ||
          searchText.includes('tws') ||
          searchText.includes('earbud');
      });
      
      if (bagProducts.length > 0) {
        filtered = bagProducts;
        console.log(`üîß Bags fallback search: ${beforeCount} ‚Üí ${filtered.length} products (found ${bagProducts.length} bag products across all categories)`);
        // Don't update state here - will be handled in useEffect
      } else {
        // Remove non-bag products, keep the rest
        filtered = filtered.filter(product => !nonBagProducts.includes(product));
        console.log(`üîß Bags fallback search: ${beforeCount} ‚Üí ${filtered.length} products (removed ${nonBagProducts.length} non-bag products)`);
        // Don't update state here - will be handled in useEffect
      }
    }
    
    // If we have a search term, rank results by relevance
    if (searchTerm && searchTerm.trim()) {
      const query = searchTerm.toLowerCase().trim();
      const queryWords = query.split(/\s+/).filter(w => w.length > 0);
      
      // First filter: Only include products where ALL words match (AND logic)
      // Also handle variations like "II" matching "2", "III" matching "3", etc.
      filtered = filtered.filter(product => {
        const nameLower = product.name.toLowerCase();
        const brandLower = product.brand.toLowerCase();
        const searchText = `${nameLower} ${brandLower}`;
        
        // Check if ALL query words are found in the product name or brand
        return queryWords.every(word => {
          // Normalize word for matching (handle roman numerals and numbers)
          const normalizedWord = word.toLowerCase().trim();
          
          // Check direct match first
          if (searchText.includes(normalizedWord)) {
            return true;
          }
          
          // Handle roman numeral and number variations
          // "ii" should match "2", "two", "ii", "iii" (if we're lenient)
          // "2" should match "ii", "two", "2"
          const variations: string[] = [normalizedWord];
          
          // Add number variations
          if (normalizedWord === 'ii' || normalizedWord === '2' || normalizedWord === 'two') {
            variations.push('ii', '2', 'two', 'iii', '3', 'three', 'iv', '4', 'four');
          } else if (normalizedWord === 'iii' || normalizedWord === '3' || normalizedWord === 'three') {
            variations.push('ii', '2', 'two', 'iii', '3', 'three', 'iv', '4', 'four');
          } else if (normalizedWord === 'iv' || normalizedWord === '4' || normalizedWord === 'four') {
            variations.push('iii', '3', 'three', 'iv', '4', 'four', 'v', '5', 'five');
          } else if (/^\d+$/.test(normalizedWord)) {
            // If it's a number, also check for roman numerals
            const num = parseInt(normalizedWord, 10);
            if (num === 2) variations.push('ii', 'two');
            if (num === 3) variations.push('iii', 'three');
            if (num === 4) variations.push('iv', 'four');
            if (num === 5) variations.push('v', 'five');
          }
          
          // Check if any variation matches
          return variations.some(variation => searchText.includes(variation));
        });
      });
      
      // Score and rank products (only those that match all words)
      const scoredProducts = filtered.map(product => {
        const nameLower = product.name.toLowerCase();
        const brandLower = product.brand.toLowerCase();
        const searchText = `${nameLower} ${brandLower}`;
        
        let score = 0;
        
        // Exact phrase match (highest priority) - e.g., "cloud 2" should match "Cloud 2" exactly
        const exactPhraseRegex = new RegExp(`\\b${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/\s+/g, '\\s+')}\\b`, 'i');
        if (exactPhraseRegex.test(nameLower)) {
          score += 2000; // Highest priority for exact phrase match
        }
        
        // Exact match in name (very high priority)
        if (nameLower === query) score += 1000;
        else if (nameLower.startsWith(query)) score += 500;
        else if (nameLower.includes(query)) score += 200;
        
        // Brand match
        if (brandLower === query) score += 300;
        else if (brandLower.includes(query)) score += 100;
        
        // Word-by-word matching (for multi-word queries like "cloud 2")
        const nameWords = nameLower.split(/\s+/);
        let wordMatchScore = 0;
        
        queryWords.forEach((word, index) => {
          nameWords.forEach((nameWord, nameIndex) => {
            if (nameWord === word) {
              // Exact word match - higher score if words are in same position
              if (index === nameIndex) wordMatchScore += 150;
              else wordMatchScore += 50;
            } else if (nameWord.startsWith(word)) {
              wordMatchScore += 30;
            } else if (nameWord.includes(word)) {
              wordMatchScore += 10;
            }
          });
        });
        
        score += wordMatchScore * 1.5; // Boost for word matches
        
        // Boost score if query appears early in the name
        const queryIndex = nameLower.indexOf(query);
        if (queryIndex >= 0 && queryIndex < 10) score += 50;
        
        return { product, score };
      });
      
      // Sort by score (descending) and extract products
      filtered = scoredProducts
        .sort((a, b) => b.score - a.score)
        .map(item => item.product);
    }
    
    // If no internal category filter (e.g., laptops), return all products
    if (!internalCategoryFilter) {
      return filtered;
    }
    
    // For PC components, double-check that products match the expected category
    const categoryFiltered = filtered.filter(product => {
      const matches = product.category === internalCategoryFilter;
      return matches;
    });
    
    return categoryFiltered;
  }, [allProducts, internalCategoryFilter, categoryParam, searchTerm, searchCategoryMatch, loading, shouldSearchAllForBags, bagsFallbackActive, wooCommerceCategoryIds]);

  // Paginate filtered products
  // For search and laptop accessories cooler: paginate client-side after filtering
  // For other categories: products already paginated by API
  const productsPerPage = 24;
  const products = useMemo(() => {
    const needsClientSidePagination = isSearching || (isLaptopAccessoriesCooler && allFilteredProducts.length > productsPerPage);
    if (needsClientSidePagination && allFilteredProducts.length > productsPerPage) {
      // Client-side pagination for search results and laptop accessories cooler
      const startIndex = (page - 1) * productsPerPage;
      const endIndex = startIndex + productsPerPage;
      return allFilteredProducts.slice(startIndex, endIndex);
    }
    return allFilteredProducts;
  }, [allFilteredProducts, page, isSearching, isLaptopAccessoriesCooler]);

  // Calculate correct totals
  const filteredTotalProducts = allFilteredProducts.length;
  const displayTotalProducts = (isSearching || isLaptopAccessoriesCooler)
    ? filteredTotalProducts  // For search and laptop accessories cooler: use filtered count
    : (totalProducts ?? filteredTotalProducts); // For other categories: use API total
  const totalPages = (isSearching || isLaptopAccessoriesCooler)
    ? Math.ceil(filteredTotalProducts / productsPerPage) // Client-side pagination
    : (totalProducts ? Math.ceil(totalProducts / productsPerPage) : (filteredTotalProducts > 0 ? 1 : 0)); // API pagination

  const handleSearch = (value: string) => {
    const newParams = { ...Object.fromEntries(searchParams) };
    if (value) {
      newParams.search = value;
    } else {
      delete newParams.search; // Remove search param if empty
    }
    newParams.page = '1'; // Reset to first page on new search
    setSearchParams(newParams);
  };

  const handleSortChange = (value: string) => {
    const [sort, order] = value.split('-');
    setSearchParams({ ...Object.fromEntries(searchParams), sort, order, page: '1' });
  };

  const handlePageChange = (newPage: number) => {
    setSearchParams({ ...Object.fromEntries(searchParams), page: newPage.toString() });
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };


  return (
    <div className="min-h-screen bg-background flex flex-col">
      <MainHeader
        onMenuClick={() => setSidebarOpen(!sidebarOpen)}
        activeTab="products"
        onTabChange={handleTabChange}
      />

      <div className="flex-1 flex">
        <CategorySidebar
          isOpen={sidebarOpen}
          onClose={() => setSidebarOpen(false)}
          onCategorySelect={(categoryId) => {
            navigate(`/products?category=${encodeURIComponent(categoryId)}`);
            setSidebarOpen(false);
          }}
        />

        <main className="flex-1 min-w-0">
        <div className="p-4 lg:p-6">
          {/* Header */}
          <div className="mb-6">
            <h1 className="text-2xl md:text-3xl font-bold mb-2">
              {categoryParam ? `${categoryParam.charAt(0).toUpperCase() + categoryParam.slice(1).replace(/-/g, ' ')}` : 'All Products'}
            </h1>
            {categoryParam && (
              <p className="text-sm text-muted-foreground mb-2">
                Filtered by: <span className="font-medium">{categoryParam.replace(/-/g, ' ')}</span>
              </p>
            )}
            {displayTotalProducts > 0 && (
              <p className="text-muted-foreground">
                Showing {products.length} of {displayTotalProducts} products
                {totalPages > 1 && ` (Page ${page} of ${totalPages})`}
              </p>
            )}
            {displayTotalProducts === 0 && !loading && (
              <p className="text-muted-foreground">No products found</p>
            )}
          </div>

          {/* Search and Filters */}
          <div className="mb-6 space-y-4">
            <div className="flex flex-col md:flex-row gap-4">
              {/* Search */}
              <div className="relative flex-1">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  placeholder="Search products..."
                  value={search}
                  onChange={(e) => handleSearch(e.target.value)}
                  className="pl-10"
                />
              </div>

              {/* Sort */}
              <Select value={`${sortBy}-${sortOrder}`} onValueChange={handleSortChange}>
                <SelectTrigger className="w-full md:w-[200px]">
                  <SelectValue placeholder="Sort by" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="date-desc">Newest First</SelectItem>
                  <SelectItem value="date-asc">Oldest First</SelectItem>
                  <SelectItem value="price-asc">Price: Low to High</SelectItem>
                  <SelectItem value="price-desc">Price: High to Low</SelectItem>
                  <SelectItem value="title-asc">Name: A to Z</SelectItem>
                  <SelectItem value="title-desc">Name: Z to A</SelectItem>
                </SelectContent>
              </Select>

              {/* View Mode */}
              <div className="flex gap-2">
                <Button
                  variant={viewMode === 'grid' ? 'default' : 'outline'}
                  size="icon"
                  onClick={() => setViewMode('grid')}
                >
                  <Grid className="h-4 w-4" />
                </Button>
                <Button
                  variant={viewMode === 'list' ? 'default' : 'outline'}
                  size="icon"
                  onClick={() => setViewMode('list')}
                >
                  <List className="h-4 w-4" />
                </Button>
              </div>
            </div>
          </div>

          {/* Products Grid/List */}
          {loading ? (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
              {Array.from({ length: 12 }).map((_, i) => (
                <div key={i} className="product-card animate-pulse">
                  <div className="h-48 bg-secondary/30 rounded-md mb-3" />
                  <div className="h-4 bg-secondary/30 rounded mb-2" />
                  <div className="h-6 bg-secondary/30 rounded mb-2" />
                  <div className="h-8 bg-secondary/30 rounded" />
                </div>
              ))}
            </div>
          ) : error ? (
            <div className="text-center py-12">
              <p className="text-destructive mb-4">Error loading products: {error.message}</p>
              <Button onClick={() => window.location.reload()}>Retry</Button>
            </div>
          ) : products.length === 0 ? (
            <div className="text-center py-12">
              <p className="text-muted-foreground mb-4">No products found</p>
              {search && (
                <Button variant="outline" onClick={() => handleSearch('')}>
                  Clear Search
                </Button>
              )}
            </div>
          ) : (
            <>
              <div
                className={
                  viewMode === 'grid'
                    ? 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4'
                    : 'space-y-4'
                }
              >
                {products.map((product) => (
                  <ProductCard key={product.id} product={product} viewMode={viewMode} />
                ))}
              </div>

              {/* Pagination */}
              {totalPages > 1 && (
                <div className="flex items-center justify-center gap-2 mt-8">
                  <Button
                    variant="outline"
                    disabled={page === 1}
                    onClick={() => handlePageChange(page - 1)}
                  >
                    Previous
                  </Button>
                  <div className="flex items-center gap-2">
                    {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
                      let pageNum;
                      if (totalPages <= 5) {
                        pageNum = i + 1;
                      } else if (page <= 3) {
                        pageNum = i + 1;
                      } else if (page >= totalPages - 2) {
                        pageNum = totalPages - 4 + i;
                      } else {
                        pageNum = page - 2 + i;
                      }
                      return (
                        <Button
                          key={pageNum}
                          variant={page === pageNum ? 'default' : 'outline'}
                          onClick={() => handlePageChange(pageNum)}
                          className="min-w-[40px]"
                        >
                          {pageNum}
                        </Button>
                      );
                    })}
                  </div>
                  <Button
                    variant="outline"
                    disabled={page === totalPages}
                    onClick={() => handlePageChange(page + 1)}
                  >
                    Next
                  </Button>
                </div>
              )}
            </>
          )}
        </div>
        </main>
      </div>

      <Footer onTabChange={handleTabChange} />
      <WhatsAppWidget />
      <BackToTop />
    </div>
  );
};

interface ProductCardProps {
  product: PCComponent;
  viewMode: 'grid' | 'list';
}

const ProductCard = ({ product, viewMode }: ProductCardProps) => {
  const { addToCart } = useCart();
  const [currentImageIndex, setCurrentImageIndex] = React.useState(0);
  
  // Get all available images (use images array if available, otherwise fallback to single image)
  const images = product.images && product.images.length > 0 ? product.images : [product.image];
  const currentImage = images[currentImageIndex] || product.image;

  const handleAddToCart = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    addToCart(product, 1);
  };

  const handleMouseEnter = () => {
    if (images.length > 1) {
      // Show next image on hover
      setCurrentImageIndex((prev) => (prev + 1) % images.length);
    }
  };

  const handleMouseLeave = () => {
    // Reset to first image when mouse leaves
    setCurrentImageIndex(0);
  };

  if (viewMode === 'list') {
    return (
      <Link to={`/product/${product.id}`} className="block">
        <div className="product-card group flex gap-4 p-4 cursor-pointer">
          <div className="w-32 h-32 flex-shrink-0 flex items-center justify-center bg-secondary/30 rounded-md overflow-hidden">
            <img
              src={currentImage}
              alt={product.name}
              className="w-full h-full object-contain"
            />
          </div>
          <div className="flex-1">
            <p className="text-xs text-muted-foreground mb-1">{product.brand}</p>
            <h3 className="text-lg font-medium mb-2">{product.name}</h3>
            <div className="flex items-center justify-between">
              <div>
                <div className="flex items-baseline gap-2 mb-2">
                  <span className="text-xl font-bold">${product.price.toFixed(2)}</span>
                </div>
                <p className={`text-sm ${product.inStock ? 'text-green-600' : 'text-red-500'}`}>
                  {product.inStock ? '‚úì In Stock' : 'Out of Stock'}
                </p>
              </div>
              <Button
                size="sm"
                className="bg-accent hover:bg-accent/90 text-white"
                disabled={!product.inStock}
                onClick={handleAddToCart}
              >
                <ShoppingCart className="h-4 w-4 mr-1" />
                Add to Cart
              </Button>
            </div>
          </div>
        </div>
      </Link>
    );
  }

  return (
    <Link to={`/product/${product.id}`} className="block h-full">
      <div 
        className="product-card group h-full cursor-pointer relative"
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
      >
        <Button
          variant="ghost"
          size="icon"
          className="absolute top-2 right-2 h-8 w-8 opacity-0 group-hover:opacity-100 transition-opacity bg-white/80 hover:bg-white z-10"
        >
          <Heart className="h-4 w-4" />
        </Button>

        <div className="aspect-square flex items-center justify-center mb-3 bg-secondary/30 rounded-md overflow-hidden">
          <img
            src={currentImage}
            alt={product.name}
            className="w-full h-full object-contain transition-opacity duration-300"
          />
        </div>

        <p className="text-xs text-muted-foreground mb-1">{product.brand}</p>
        <h3 className="text-sm font-medium line-clamp-2 mb-2 min-h-[40px]">{product.name}</h3>

        <div className="flex items-baseline gap-2 mb-2">
          <span className="text-lg font-bold">${product.price.toFixed(2)}</span>
        </div>

        <p className={`text-xs mb-2 ${product.inStock ? 'text-green-600' : 'text-red-500'}`}>
          {product.inStock ? '‚úì In Stock' : 'Out of Stock'}
        </p>

        <Button
          size="sm"
          className="w-full bg-accent hover:bg-accent/90 text-white text-xs"
          disabled={!product.inStock}
          onClick={handleAddToCart}
        >
          <ShoppingCart className="h-3 w-3 mr-1" />
          Add to Cart
        </Button>
      </div>
    </Link>
  );
};

export default Products;

